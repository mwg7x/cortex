import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const DB_PATH = path.resolve(__dirname, "..", "data", "patients.json");

type Report = { text: string; timestamp: string };
type FeedbackSender = "patient" | "doctor";
type FeedbackMessage = Report & { sender?: FeedbackSender };
type ConditionRecord = { condition: string; timestamp: string };
export type MedicalHistoryRecord = {
  id: string;
  category:
    | "symptom_report"
    | "condition_recorded"
    | "medication_plan_generated"
    | "message_patient"
    | "message_doctor";
  title: string;
  details: string;
  timestamp: string;
};

export type Analysis = {
  isSafe: boolean;
  interactions: Array<{
    medications: [string, string];
    severity: "minor" | "moderate" | "major" | "contraindicated";
    reason: string;
    canSeparateBySchedule: boolean;
    minHoursApart?: number;
  }>;
  recommendations: Array<{
    type: "keep_and_separate" | "replace_medication" | "avoid_combination";
    title: string;
    details: string;
  }>;
  schedule: Array<{
    medication: string;
    times: string[];
    note?: string;
  }>;
};

export type Patient = {
  id: string;
  name: string;
  labels?: string[];
  reports: Report[];
  medications?: any[];
  condition?: string; // Set by doctor
  conditionsHistory?: ConditionRecord[];
  analysis?: Analysis; // Generated by AI after doctor sets condition
  feedback?: FeedbackMessage[]; // Patient/doctor conversation about medications
  medicalHistory?: MedicalHistoryRecord[];
  createdAt: string;
};

type DBShape = { patients: Patient[] };

function ensureDbFile() {
  const dir = path.dirname(DB_PATH);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  if (!fs.existsSync(DB_PATH)) {
    fs.writeFileSync(DB_PATH, JSON.stringify({ patients: [] }));
  }
}

function readDb(): DBShape {
  ensureDbFile();
  const raw = fs.readFileSync(DB_PATH, "utf8");
  try {
    return JSON.parse(raw) as DBShape;
  } catch {
    return { patients: [] };
  }
}

function writeDb(db: DBShape) {
  ensureDbFile();
  fs.writeFileSync(DB_PATH, JSON.stringify(db, null, 2));
}

function buildHistoryId() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}

function ensurePatientCollections(patient: Patient) {
  if (!patient.reports) patient.reports = [];
  if (!patient.feedback) patient.feedback = [];
  if (!patient.conditionsHistory) patient.conditionsHistory = [];
  if (!patient.medicalHistory) patient.medicalHistory = [];
}

function addHistoryRecord(
  patient: Patient,
  record: Omit<MedicalHistoryRecord, "id">,
) {
  ensurePatientCollections(patient);
  patient.medicalHistory!.push({ id: buildHistoryId(), ...record });
}

function sortByTimestampDesc<T extends { timestamp: string }>(items: T[]) {
  return items
    .slice()
    .sort(
      (a, b) =>
        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime(),
    );
}

export function listPatients(): Patient[] {
  return readDb().patients;
}

export function getPatient(id: string): Patient | undefined {
  return readDb().patients.find((p) => p.id === id);
}

export function addPatient(patient: Patient) {
  const db = readDb();
  const normalized: Patient = {
    ...patient,
    reports: patient.reports ?? [],
    feedback: patient.feedback ?? [],
    conditionsHistory: patient.conditionsHistory ?? [],
    medicalHistory: patient.medicalHistory ?? [],
  };
  db.patients.push(normalized);
  writeDb(db);
}

export function deletePatient(id: string): boolean {
  const db = readDb();
  const before = db.patients.length;
  db.patients = db.patients.filter((p) => p.id !== id);
  writeDb(db);
  return db.patients.length < before;
}

export function addReport(id: string, text: string) {
  const db = readDb();
  const p = db.patients.find((x) => x.id === id);
  if (!p) return false;
  ensurePatientCollections(p);
  const timestamp = new Date().toISOString();
  p.reports.push({ text, timestamp });
  addHistoryRecord(p, {
    category: "symptom_report",
    title: "Symptom Report Submitted",
    details: text,
    timestamp,
  });
  writeDb(db);
  return true;
}

export function setLabels(id: string, labels: string[]) {
  const db = readDb();
  const p = db.patients.find((x) => x.id === id);
  if (!p) return false;
  p.labels = labels;
  writeDb(db);
  return true;
}

export function setCondition(id: string, condition: string) {
  const db = readDb();
  const p = db.patients.find((x) => x.id === id);
  if (!p) return false;
  ensurePatientCollections(p);
  const timestamp = new Date().toISOString();
  p.condition = condition;
  p.conditionsHistory!.push({ condition, timestamp });
  addHistoryRecord(p, {
    category: "condition_recorded",
    title: "Condition Recorded",
    details: condition,
    timestamp,
  });
  writeDb(db);
  return true;
}

export function setAnalysis(id: string, analysis: Analysis) {
  const db = readDb();
  const p = db.patients.find((x) => x.id === id);
  if (!p) return false;
  ensurePatientCollections(p);
  p.analysis = analysis;
  p.medications = analysis.schedule.map((s) => ({
    name: s.medication,
    dose: "per schedule",
    frequencyPerDay: 1,
  }));
  const summary = analysis.schedule
    .map((slot) => `${slot.medication} (${slot.times.join(", ")})`)
    .join(" | ");
  addHistoryRecord(p, {
    category: "medication_plan_generated",
    title: "Medication Plan Generated",
    details: summary || "Medication plan created by doctor.",
    timestamp: new Date().toISOString(),
  });
  writeDb(db);
  return true;
}

export function addFeedback(
  id: string,
  text: string,
  sender: FeedbackSender = "patient",
) {
  const db = readDb();
  const p = db.patients.find((x) => x.id === id);
  if (!p) return false;
  ensurePatientCollections(p);
  const timestamp = new Date().toISOString();
  p.feedback!.push({ text, timestamp, sender });
  addHistoryRecord(p, {
    category: sender === "doctor" ? "message_doctor" : "message_patient",
    title: sender === "doctor" ? "Doctor Message" : "Patient Message",
    details: text,
    timestamp,
  });
  writeDb(db);
  return true;
}

function deriveFallbackHistory(patient: Patient): MedicalHistoryRecord[] {
  const fallback: MedicalHistoryRecord[] = [];
  const conditionHistory = patient.conditionsHistory ?? [];

  for (const report of patient.reports ?? []) {
    fallback.push({
      id: buildHistoryId(),
      category: "symptom_report",
      title: "Symptom Report Submitted",
      details: report.text,
      timestamp: report.timestamp,
    });
  }

  for (const conditionRecord of conditionHistory) {
    fallback.push({
      id: buildHistoryId(),
      category: "condition_recorded",
      title: "Condition Recorded",
      details: conditionRecord.condition,
      timestamp: conditionRecord.timestamp,
    });
  }

  if (patient.condition && conditionHistory.length === 0) {
    fallback.push({
      id: buildHistoryId(),
      category: "condition_recorded",
      title: "Condition Recorded",
      details: patient.condition,
      timestamp: patient.createdAt,
    });
  }

  for (const feedback of patient.feedback ?? []) {
    fallback.push({
      id: buildHistoryId(),
      category:
        feedback.sender === "doctor" ? "message_doctor" : "message_patient",
      title: feedback.sender === "doctor" ? "Doctor Message" : "Patient Message",
      details: feedback.text,
      timestamp: feedback.timestamp,
    });
  }

  return sortByTimestampDesc(fallback);
}

export function getPatientMedicalHistory(id: string) {
  const patient = getPatient(id);
  if (!patient) return undefined;

  const history =
    patient.medicalHistory && patient.medicalHistory.length > 0
      ? sortByTimestampDesc(patient.medicalHistory)
      : deriveFallbackHistory(patient);

  const conditionsHistory = sortByTimestampDesc(patient.conditionsHistory ?? []);

  return {
    id: patient.id,
    name: patient.name,
    createdAt: patient.createdAt,
    currentCondition: patient.condition ?? null,
    conditionsHistory,
    medicalHistory: history,
  };
}
